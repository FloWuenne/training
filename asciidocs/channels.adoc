= Channels 

Channels are a key data structure of Nextflow that allows the implementation
of reactive-functional oriented computational workflows based on the https://en.wikipedia.org/wiki/Dataflow_programming[Dataflow] programming paradigm.

They are used to logically connect tasks each other or to implement functional style data transformations.

image::channel-files.png[]

== Channel types

Nextflow distinguish two different kinds of channels: *queue* channels and *value* channels.

=== Queue channel

A _queue_ channel is a _asynchronous_ unidirectional _FIFO_ queue which connects two processes or operators.

* What _asynchronous_ means? That operations are non-blocking.

* What _unidirectional_ means? That data flow from a producer to a consumer.

* What _FIFO_ means? That the data is guaranteed to be delivered in the same order as it is produced. First In, First Out.

A queue channel is implicitly created by process output definitions or using channel factories methods
such as https://www.nextflow.io/docs/latest/channel.html#from[Channel.from] or https://www.nextflow.io/docs/latest/channel.html#frompath[Channel.fromPath].

Try the following snippets:

[source,nextflow,linenums]
----
ch = Channel.from(1,2,3)
println(ch)     // <1>
ch.view()       // <2>
----


<1> Use the built-in `println` function to print the `ch` variable.
<2> Apply the `view` method to the `ch` channel, therefore prints each item emitted by the channels.


==== Exercise

Try to execute this snippet, it will produce an error message.

[source,nextflow,linenums]
----
ch = Channel.from(1,2,3)
ch.view()
ch.view()
----

IMPORTANT: A queue channel can have one and exactly one producer and one and exactly one consumer.

=== Value channels

A *value* channel a.k.a. singleton channel by definition is bound to a single value and it can be read unlimited times without consuming its content.

[source,nextflow,linenums]
----
ch = Channel.value('Hello')
ch.view()
ch.view()
ch.view()
----

It prints:

```
Hello
Hello
Hello
```

== Channel factories


=== value

The `value` factory method is used to create a _value_ channel. An optional not ``null`` argument
can be specified to bind the channel to a specific value. For example:

[source,nextflow,linenums]
----
ch1 = Channel.value()                 // <1>
ch2 = Channel.value( 'Hello there' )  // <2>
ch2 = Channel.value( [1,2,3,4,5] )    // <3>
----

<1> Creates an _empty_ value channel.
<2> Creates a value channel and binds a string to it.
<3> Creates a value channel and binds a list object to it that will be emitted as a sole emission.

=== from

The factory `Channel.from` allows the creation of a queue channel with the values specified as argument.

[source,nextflow,linenums]
----
ch = Channel.from( 1, 3, 5, 7 )
ch.view{ "value: $it" }
----

The first line in this example creates a variable `ch` which holds a channel object. This channel emits the values specified as a parameter in the `from` method. Thus the second line will print the following:

----
value: 1
value: 3
value: 5
value: 7
----


IMPORTANT: Method `Channel.from` will be deprecated and replaced by `Channel.of` (see 
  below). 

=== of 

The method `Channel.of` works in a similar manner to `Channel.from`, though it fixes
some inconsistent behavior of the latter and provides a better handling for range of values. 
For example:

[source,nextflow,linenums]
----
Channel
    .of(1..23, 'X', 'Y')
    .view()
----

=== fromList

The method `Channel.fromList` creates a channel emitting the elements provided 
by a list objects specified as argument:

[source,nextflow,linenums]
----
list = ['hello', 'world']

Channel
    .fromList(list)
    .view()
----

=== fromPath

The `fromPath` factory method create a queue channel emitting one or more files
matching the specified glob pattern.

[source,nextflow,linenums]
----
Channel.fromPath( '/data/big/*.txt' )
----

This example creates a channel and emits as many items as there are files with `txt` extension in the `/data/big` folder. Each element is a file object implementing the https://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html[Path] interface.

TIP: Two asterisks, i.e. `\**`, works like `*` but crosses directory boundaries. This syntax is generally used for matching complete paths. Curly brackets specify a collection of sub-patterns.


.Available options
[%header,cols="15%,85%"]
|===
|Name
|Description

|glob
|When ``true`` interprets characters ``*``, ``?``, ``[]`` and ``{}`` as glob wildcards, otherwise handles them as normal characters (default: ``true``)

|type
| Type of paths returned, either ``file``, ``dir`` or ``any`` (default: ``file``)

|hidden
| When ``true`` includes hidden files in the resulting paths (default: ``false``)

|maxDepth
| Maximum number of directory levels to visit (default: `no limit`)

|followLinks
| When ``true`` it follows symbolic links during directories tree traversal, otherwise they are managed as files (default: ``true``)

|relative
| When ``true`` returned paths are relative to the top-most common directory (default: ``false``)

|checkIfExists
| When ``true`` throws an exception of the specified path do not exist in the file system (default: ``false``)
|===

Learn more about the glob patterns syntax at https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob[this link].

==== Exercise

Use the `Channel.fromPath` method to create a channel emitting all files with the suffix `.fq` in the `data/ggal/` and any subdirectory, then print the file name.


=== fromFilePairs

The `fromFilePairs` method creates a channel emitting the file pairs matching a glob pattern provided by the user. The matching files are emitted as tuples in which the first element is the grouping key of the matching pair and the second element is the list of files (sorted in lexicographical order).

[source,nextflow,linenums]
----
Channel
    .fromFilePairs('/my/data/SRR*_{1,2}.fastq')
    .view()
----

It will produce an output similar to the following:

```
[SRR493366, [/my/data/SRR493366_1.fastq, /my/data/SRR493366_2.fastq]]
[SRR493367, [/my/data/SRR493367_1.fastq, /my/data/SRR493367_2.fastq]]
[SRR493368, [/my/data/SRR493368_1.fastq, /my/data/SRR493368_2.fastq]]
[SRR493369, [/my/data/SRR493369_1.fastq, /my/data/SRR493369_2.fastq]]
[SRR493370, [/my/data/SRR493370_1.fastq, /my/data/SRR493370_2.fastq]]
[SRR493371, [/my/data/SRR493371_1.fastq, /my/data/SRR493371_2.fastq]]
```

IMPORTANT: The glob pattern must contain at least a star wildcard character.

.Available options
[%header,cols="15%,85%"]
|===
|Name
|Description

|type
|Type of paths returned, either ``file``, ``dir`` or ``any`` (default: ``file``)

|hidden
|When ``true`` includes hidden files in the resulting paths (default: ``false``)

|maxDepth
|Maximum number of directory levels to visit (default: `no limit`)

|followLinks
| When ``true`` it follows symbolic links during directories tree traversal, otherwise they are managed as files (default: ``true``)

|size
| Defines the number of files each emitted item is expected to hold (default: 2). Set to ``-1`` for any.

|flat
|When ``true`` the matching files are produced as sole elements in the emitted tuples (default: ``false``).

|checkIfExists
| When ``true`` throws an exception of the specified path do not exist in the file system (default: ``false``)
|===

==== Exercise

Use the `fromFilePairs` method to create a channel emitting all pairs of fastq read in the `data/ggal/`
directory and print them.

Then use the `flat:true` option and compare the output with the previous execution.

=== fromSRA 

The `Channel.fromSRA` method that makes it possible to query of https://www.ncbi.nlm.nih.gov/sra[NCBI SRA] archive and returns a channel emitting the FASTQ files matching the specified selection criteria.

The query can be project ID or accession number(s) supported by the 
https://www.ncbi.nlm.nih.gov/books/NBK25499/#chapter4.ESearch[NCBI ESearch API].
For example the following snippet:

[source,nextflow,linenums]
----
Channel
    .fromSRA('SRP043510')
    .view()
----

prints: 

[source,text,linenums]
----
[SRR1448794, ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR144/004/SRR1448794/SRR1448794.fastq.gz]
[SRR1448795, ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR144/005/SRR1448795/SRR1448795.fastq.gz]
[SRR1448792, ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR144/002/SRR1448792/SRR1448792.fastq.gz]
[SRR1448793, ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR144/003/SRR1448793/SRR1448793.fastq.gz]
[SRR1910483, ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR191/003/SRR1910483/SRR1910483.fastq.gz]
[SRR1910482, ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR191/002/SRR1910482/SRR1910482.fastq.gz]
(remaining omitted)
----


Multiple accession IDs can be specified using a list object:

[source,nextflow,linenums]
----
ids = ['ERR908507', 'ERR908506', 'ERR908505']
Channel
    .fromSRA(ids)
    .view()
----

[source,text,linenums]
----
[ERR908507, [ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR908/ERR908507/ERR908507_1.fastq.gz, ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR908/ERR908507/ERR908507_2.fastq.gz]]
[ERR908506, [ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR908/ERR908506/ERR908506_1.fastq.gz, ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR908/ERR908506/ERR908506_2.fastq.gz]]
[ERR908505, [ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR908/ERR908505/ERR908505_1.fastq.gz, ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR908/ERR908505/ERR908505_2.fastq.gz]]
----

TIP: Read pairs are implicitly managed are returned as a list of files.

It's straightforward to use this channel as an input using the usual Nextflow 
syntax. For example: 

[source,nextflow,linenums]
----
params.accession = 'SRP043510'
reads = Channel.fromSRA(params.accession)

process fastqc {
    input:
    tuple sample_id, file(reads_file) from reads

    output:
    file("fastqc_${sample_id}_logs") into fastqc_ch

    script:
    """
    mkdir fastqc_${sample_id}_logs
    fastqc -o fastqc_${sample_id}_logs -f fastq -q ${reads_file}
    """
}
----

The code snippet above creates a channel containing 24 samples from a chromatin dynamics study and runs FASTQC on the resulting files.

